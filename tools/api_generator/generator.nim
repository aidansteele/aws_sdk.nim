import json, sets, strutils, os

type Ctx = ref object
    typesDone: HashSet[string]
    typeDescs: seq[string]
    codeSection: string
    clientClassName: string
    jDesc: JsonNode

proc newCtx(jDesc: JsonNode): Ctx =
    result.new()
    result.typeDescs = @[]
    result.codeSection = ""
    result.jDesc = jDesc
    result.typesDone = initSet[string]()

when false:
    proc genType(c: Ctx, name: string, desc: JsonNode) =
        if name in c.typesDone: return
        c.typesDone.incl(name)

        var res = "  " & name & "* = "
        let jTyp = desc["type"].str
        case jTyp
        of "string":
            res &= "string"
        of "list":
            res &= "seq[" & desc["member"]["shape"].str & "]"
        of "map":
            res &= "Table[" & desc["key"]["shape"].str & ", " & desc["value"]["shape"].str & "]"
        else:
            discard
        res &= "\L"
        c.typeDescs.add(res)

    proc genTypes(c: Ctx) =
        let jShapes = c.jDesc["shapes"]

        for k, v in jShapes:
            c.genType(k, v)

proc decapitalize(s: string): string =
    toLowerAscii(s[0]) & s[1 .. ^1]

proc genProc(c: Ctx, name: string, desc: JsonNode) =
    let htMeth = desc["http"]["method"].str
    let uri = desc["http"]["requestUri"].str
    let p = "proc " & decapitalize(name) & "*(cl: " & c.clientClassName & ", r: JsonNode): Future[JsonNode] = sendJsonRequest(cl, \"" & name & "\", \"" & htMeth & "\", \"" & uri & "\", r)\L"
    c.codeSection &= p

proc genProcs(c: Ctx) =
    let jOps = c.jDesc["operations"]
    for k, v in jOps:
        c.genProc(k, v)

proc writeToFile(c: Ctx, filename: string) =
    var o = "# This file is autogenerated, do not modify\L"
    o &= "import json, asyncfutures\L"
    o &= "import utils/client\L"
    o &= "export client.new\L"

    for k, v in c.jDesc["metadata"]:
        o &= "const awsApiMD_" & k & "* = \"" & v.str & "\"\L"

    o &= "defineClient(" & c.clientClassName & ")\L"
    if c.typeDescs.len != 0:
        o &= "type\L"
        for d in c.typeDescs:
            o &= d
            o &= "\L"
    o &= c.codeSection
    writeFile(filename, o)

when isMainModule:
    if paramCount() != 3:
        raise newException(Exception, "InvalidArguments")

    let apiJsonFile = paramStr(1)
    let clientClassName = paramStr(2)
    let outputNimFile = paramStr(3)

    let c = newCtx(parseFile(apiJsonFile))
    c.clientClassName = clientClassName
    # c.genTypes()
    c.genProcs()
    c.writeToFile(outputNimFile)

